[1. 데이터 모델링의 이해](#1-데이터-모델링의-이해)

​	[1. 데이터 모델링](#1-데이터-모델링)

​	[2. 데이터 모델과 성능](#2-데이터-모델과-성능)

2. SQL 기본 및 활용

1. SQL 기본
2. SQL 활용
3. SQL 최적화의 원리

---------------

# 1. 데이터 모델링의 이해

### 1. 데이터 모델링

**데이터 모델링**을 하기 위해서는 고객과의 의사소통을 통해 고객의 업무 프로세스를 이해해야 한다.

**① 데이터 모렐링의 특징** : 추상화, 단순화, 명확성

**② 데이터 모델링 단계** 

 	1. 개념적 모델링 : 추상화 수준이 가장 높은 모델링, 전사적 관점에서 기업의 데이터 모델링
 	2. 논리적 모델링 : 정규화를 통해 재사용성 높임, 식별자 정의하고 관계, 속성 표현
 	3. 물리적 모델링 : 성능, 보안, 가용성 고려하여 데이터베이스 구축

- 데이터 모델링 관점
  - 데이터 : 비즈니스 프로세스에 사용되는 데이터를 의미한다. (구조 분석, 정적 분석)
  - 프로세스 : 비즈니스 프로세스에서 수행하는 작업을 의미한다. (시나리오 분석, 도메인 분석, 동적 분석)
  - 데이터와 프로세스 : 스로세스와 데이터 간의 관계를 의미한다. (CRUD 분석)

**③ ERD (Entity Relationship Diagram) 작성 절차**

- 엔터티를 도출하고 그린다
- 엔터티를 배치한다 : 중요한 엔터티 왼쪽 상단에 배치
- 엔터티 간의 관계를 설정한다
- 관계명을 서술한다.
- 관계 참여도 표현
- 관계의 필수 여부 표현

**④ 3층 스키마** 

- 사용자, 설계자, 개발자 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들간의 관계를 정의한 ANSI 표준

- 3단계 계층으로 분리해서 독립성을 확보하는 방법으로 각 계층을 뷰라고도 한다.

- **3층 스키마 구조** :star:
  - 외부 스키마 : 사용자 관점, 응용 프로그램이 접근하는 데이터베이스
  - 개념 스키마 : 설계자 관점, 사용자 전체 집단의 데이터베이스 구조, 전체 데이터베이스 내의 규칙과 구조 표현
  - 내부 스키마 : 개발자 관점, 데이터베이스의 물리적 저장 구조

**⑤ 엔터티**

- 엔터티는 업무에서 관리해야 하는 데이터 집합 의미하며 저장되고 관리되어야 하는 데이터이다. 개념, 사건, 장소 등의 명사
- 엔터티는 <u>고객의 비즈니스 프로세스에서 관리되어야 하는 정보</u>를 추출
- 엔터티 특징
  - 식별자 : 엔터티는 <u>유일한 식별자가 있어야 한다</u>.
  - 인스턴스 집합 : <u>2개 이상의 인스턴스</u> 있어야 한다.
  - 속성 : <u>반드시 속성</u> 가져야 한다. 
  - 관계 : <u>다른 엔터티와 최소한 한 개 이상 관계</u>가 있어야 한다.
  - 업무 : 엔터티는 업무에서 관리되어야 하는 집합
- 엔터티 종류:star:
  - 유형/무형에 따른 엔터티 (유-개-사) 
    - **유형** : 업무에서 도출되며 지속적으로 사용되는 엔터티 (고객, 강사, 사원)
    - **개념** : 물리적 형태 없이 개념적으로 사용됨 (거래소 종목)
    - **사건** : 비즈니스 프로세스를 실행하며 생성되는 엔터티 (주문, 체결)
  - 발생 시점에 따른 엔터티
    - **기본** : 키 엔터티, 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성됨 (고객, 상품)
    - **중심** : 기본 엔터티로부터 발생되고 행위 엔터티를 생성 (주문)
    - **행위** : 2개 이상의 엔터티로부터 발생 (주문 이력)

**⑥ 속성**

엔터티가 가지는 항목으로 더 이상 분리되지 않는 단위로, 업무에 필요한 데이터 저장

- 속성의 특징 
  - 속성은 업무에서 관리되는 정보
  - 하나의 값만 가진다.
  - 주식별자에게 함수적으로 종속. (기본키가 변경되면 속성 값도 변경. `계좌번호` 바뀌면 `예수금`도 변경)
- 속성의 종류 :star:
  - 분해 여부에 따른 속성
    - 단일 : 하나의 의미로 구성 (회원ID) 
    - 복합 : 여러 개의 의미가 있는 것으로 구성 (주소→시,군,동)
    - 다중값 : 여러 개의 값을 가질 수 있음 (상품 리스트)
  - 특성에 따른 속성
    - 기본: 비지니스 프로세스에서 도출되는 본래의 속성 (이름)
    - 설계: 데이터 모델링 과정에서 발생되는 속성, 유일한 값 부여 (상품코드)
    - 파생: 다른 속성에 의해 만들어짐(평균, 합계)

**⑦ 관계**

- 관계의 종류 : 엔터티 간의 관련성을 의미하며 존재 관계와 행위 관계로 분류됨.
  - **존재 관계** : 존재 관계는 엔터티 간의 상태 의미 (`고객`은 `관리점`에서 관리된다.)
  - **행위 관계** : 엔터티 간에 어떤 행위가 있는 것 (`계좌`를 개설하고 `주문`을 발주한다.)
- 관계 차수 :  두개의 엔터티 간에 관계에 참여하는 수 (한 명의 고객은 여러 개의 계좌를 개설할 수 있음)
- 필수적 관계와 선택적 관계 
  - 필수적 관계는 반드시 하나는 존재해야 하는 관계이고 선택적 관계는 없을 수도 있는 관계이다.
  - 필수적 관계는 `|`로 표현되고 선택적 관계는 `O`로 표현된다.

**⑧ 식별 관계와 비식별 관계**

- 식별 관계
  - 독립적으로 존재할 수 있는 엔터티를 **강한 개체**라 한다.
  - 강한 개체는 어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재한다.
  - 강한 개체는 식별 관계로 표현된다.
  - 식별 관계는 실선으로 표시됨.
- 비식별 관계
  - 비식별 관계는 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것
  - 비식별 관계는 점선으로 표시됨.

**⑨ 엔터티 식별자**

- 식별자라는 것은 <u>엔터티를 대표할 수 있는 유일성을 만족하는 속성</u>

- 주식별자(기본키, Primary Key)

  - 최소성 : 주식별자는 최소성을 만족하는 키이다.
  - 대표성 : 주식별자는 엔터티를 대표할 수 있어야 한다.
  - 유일성 : 주식별자는 엔터티의 인스턴스를 유일하게 식별한다.
  - 불변성 : 주식별자는 자주 변경되지 않아야 한다.

- 키의 종류

  - 기본키 : 후보키 중에서 엔터티를 대표할 수 있는 키
  - 후보키 : 후보키는 유일성과 최소성 만족
  - 슈퍼키 : 유일성을 만족하지만 최소성 만족하지 않는 키
  - 대체키 : 여러 개의 후보키 중에서 기본키를 선정하고 남은 키
  - 외래키 : 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해서 사용

- 식별자의 종류 :star:

  - 식별자의 대표성
    - 주식별자 : 엔터티 대표하는 식별자, 다른 엔터티와 참조 관계로 연결될 수 있다.
    - 보조 식별자 : 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자
  - 생성 여부
    - 내부 식별자 : 내부 식별자는 엔터티 내부에서 스스로 생성되는 식별자 (주문번호)
    - 외부 식별자 : 다른 엔터티의 관계로 인하여 만들어지는 식별자 (계좌 엔터티의 회원ID)
  - 속성의 수
    - 단일 식별자 : 하나의 속성으로 구성
    - 복합 식별자 : 두 개 이상의 속성으로 구성
  - 대체 여부
    - 본질 식별자 : 비즈니스 프로세스에서 만들어지는 식별자
    - 인조 식별자 : 인위적으로 만들어지는 식별자

  ### 2. 데이터 모델과 성능

  **① 정규화**

  - 정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법
  - 데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법
  - 정규화 절차
    - 제1정규화 : 기본키 설정
    - 제2정규화 : 기본키가 2개 이상의 속성으로 이루어진 경우. **부분 함수 종속성**을 제거한다.
    - 제3정규화 : 기본키를 제외한 칼럼 간에 종속성 제거. **이행 함수 종속성** 제거
    - BCNF : 기본키를 제외하고 후보키 있는 경우. <u>후보키가 기본키를 종속시키면 분해</u>
    - 제4정규화
    - 제5정규화
  - 정규화 문제점
    - 정규화는 데이터 <u>조회 시에 조인</u>을 유발하기 때문에 <u>CPU와 메모리를 많이 사용</u>
    - 이중으로 for문을 사용해서 비교하는 기능을 만들어야 조인할 수 있는 경우 데이터양이 증가하면 비교해야 하는 건수도 증가 → 조인이 부하 유발
    - 정규화는 입출력 데이터의 양을 줄여서 성능을 향상시키는 방법으로 <u>조인으로 성능이 저하되는 문제는 **반정규화**로 해결</u>할 수 있다.

  **② 반정규화**

  - 반정규화는 조회 속도를 향상하지만, 데이터 모델의 유연성은 낮아진다.

  - 반정규화를 수행하는 경우

    - 정규화 시 수행 속도가 느려지는 경우
    - 다량의 범위를 자주 처리해야 하는 경우
    - 특정 범위의 데이터만 자주 처리하는 경우
    - 요약/집계 정보가 자주 요구되는 경우

  - 반정규화 기법

    - 계산된 칼럼 추가

    - 테이블 수직분할 : 칼럼을 분할하여 새로운 테이블 생성

    - 테이블 수평분할 : 하나의 테이블에 있는 값을 기준으로 테이블 분할

      \* 파티션 기법

      - Range Partition : 데이터 값의 범위를 기준으로 파티션 수행
      - List Partition : 특정한 값을 지정하여 파티션 수행
      - Hash Partition : 해시 함수를 적용하여 파티션 수행
      - Composite Partition : 범위와 해시를 복합적으로 사용 

    - 테이블 병합 : 슈퍼 타입과 서브 타입 관계 발생 시 테이블 통합하여 성능 향상

      - OneToOne Type : 슈퍼 타입과 서브 타입 <u>개별 테이블</u>로 도출(조인 많이 발생)
      - Plus Type : 슈퍼 타입과 서브 타입 테이블로 도출 (조인 발생)
      - Single Type : 슈퍼 타입과 서브 타입을 하나의 테이블로 도출 (조인 성능 좋고 관리 편하지만 입출력 성능 나쁘다)

  **③ 분산 데이터베이스**

  - 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된 작업 처리를 수행하는 데이터베이스를 **분산 데이터베이스**라고 한다.
  - 분산 데이터베이스의 투명성 종류 :star:
    - 분할 투명성 : 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있음을 인식할 필요 없다.
    - 위치 투명성 : 데이터의 저장 장소를 명시할 필요 없다. 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 한다.
    - 지역 사상 투명성 : 각 지역 시스템 이름과 무관한 이름이 사용 가능하다.
    - 중복 투명성 : 데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 데이터의 일관성이 유지.
    - 장애 투명성 : 데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터 무결성 보장
    - 병합 투명성 : 여러 고객 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없다.
  - 분산 데이터베이스 장점과 단점 :star:
    - 장점
      - 데이터베이스 **신뢰성과 가용성이 높다**
      - 분산 데이터베이스가 병렬 처리를 수행하기 때문에 **빠른 응답 가능**
      - 분산 데이터베이스를 추가하여 **시스템 용량 확장 쉽다**
    - 단점
      - 관리와 통제 어려움
      - 보안관리 어려움
      - 데이터 무결성관리 어려움
      - 데이터베이스 설계 복잡함

  

\* Live SQL (https://livesql.oracle.com)을 사용하면 설치없이 SQL문 공부 가능